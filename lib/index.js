// Generated by CoffeeScript 1.6.2
var any, contains, either, extend, isArray, isBoolean, isDate, isEmpty, isNumber, isObject, isString, optional, type, validate, _ref;

_ref = require('underscore'), extend = _ref.extend, isObject = _ref.isObject, isNumber = _ref.isNumber, isString = _ref.isString, contains = _ref.contains, isArray = _ref.isArray, isBoolean = _ref.isBoolean, isDate = _ref.isDate, isEmpty = _ref.isEmpty;

type = (function() {
  function type(params) {
    if (!(this instanceof type)) {
      return new type(params);
    }
    extend(this, params);
  }

  type.prototype.validate = function(data) {
    var errors;

    errors = "invalid data";
    return {
      errors: errors,
      data: data
    };
  };

  return type;

})();

any = (function() {
  function any() {
    if (!(this instanceof any)) {
      return new any;
    }
  }

  return any;

})();

optional = (function() {
  function optional(schema, defaultValue) {
    if (!(this instanceof optional)) {
      return new optional(schema, defaultValue);
    }
    this.schema = schema;
    this.defaultValue = defaultValue;
  }

  return optional;

})();

either = (function() {
  function either(a, b) {
    if (!(this instanceof either)) {
      return new either(a, b);
    }
    this.a = a;
    this.b = b;
  }

  return either;

})();

validate = function(schema, data, options) {
  var errors, idx, newData, subContract, tryX, x, _ref1, _ref2;

  if (options == null) {
    options = {};
  }
  errors = void 0;
  if (data === void 0) {
    if (schema instanceof optional) {
      data = schema.defaultValue;
    } else {
      errors = "missing value";
    }
    return {
      errors: errors,
      data: data
    };
  }
  if (schema instanceof type) {
    return schema.validate(data);
  }
  if (schema instanceof any || schema === any) {
    return {
      errors: errors,
      data: data
    };
  }
  if (schema instanceof optional) {
    schema = schema.schema;
  }
  if (schema instanceof either) {
    _ref1 = validate(schema.a, data, options), errors = _ref1.errors, data = _ref1.data;
    if (errors) {
      _ref2 = validate(schema.b, data, options), errors = _ref2.errors, data = _ref2.data;
    }
    return {
      errors: errors,
      data: data
    };
  }
  if (schema === Number) {
    if (options.weak) {
      data = Number(data);
    }
    if (!isNumber(data || isNaN(data))) {
      errors = "should be a number";
    }
  } else if (schema === String) {
    if (!isString(data)) {
      errors = "should be a string";
    }
  } else if (schema === Boolean) {
    if (options.weak) {
      data = contains(['true', '1', 'yes'], data.toLowerCase()) ? true : contains(['false', '0', 'no'], data.toLowerCase()) ? false : void 0;
    }
    if (!isBoolean(data)) {
      errors = "should be a bool";
    }
  } else if (schema === Date) {
    if (options.weak) {
      data = new Date(data);
    }
    if (!isDate(data || isNaN(data.getDate()))) {
      errors = "should be a date";
    }
  } else if (isArray(schema)) {
    if (!isArray(data)) {
      errors = "should be an array";
    } else {
      newData = (function() {
        var _i, _len, _results;

        _results = [];
        for (idx = _i = 0, _len = data.length; _i < _len; idx = ++_i) {
          x = data[idx];
          tryX = validate(schema[0], x, options);
          if (tryX.errors) {
            errors = errors || {};
            errors[idx] = tryX.errors;
          }
          _results.push(tryX.data);
        }
        return _results;
      })();
      return {
        errors: errors,
        data: newData
      };
    }
  } else {
    if (!isObject(data)) {
      errors = "should be an object";
    } else {
      newData = {};
      for (idx in schema) {
        subContract = schema[idx];
        tryX = validate(subContract, data[idx], options);
        if (tryX.errors) {
          errors = errors || {};
          errors[idx] = tryX.errors;
        }
        newData[idx] = tryX.data;
      }
      return {
        errors: errors,
        data: newData
      };
    }
  }
  return {
    errors: errors,
    data: data
  };
};

module.exports = {
  validate: validate,
  type: type,
  optional: optional,
  either: either,
  any: any
};
