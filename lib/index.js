// Generated by CoffeeScript 1.6.2
var any, contains, either, extend, isArray, isBoolean, isDate, isNumber, isObject, isString, optional, type, validate, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ref = require('underscore'), extend = _ref.extend, isObject = _ref.isObject, isNumber = _ref.isNumber, isString = _ref.isString, contains = _ref.contains, isArray = _ref.isArray, isBoolean = _ref.isBoolean, isDate = _ref.isDate;

type = (function() {
  function type(params) {
    if (!(this instanceof type)) {
      return new type(params);
    }
    extend(this, params);
  }

  type.prototype.validate = function(data) {
    var errors;

    errors = "invalid data";
    return {
      errors: errors,
      data: data
    };
  };

  return type;

})();

any = (function() {
  function any() {
    if (!(this instanceof any)) {
      return new any;
    }
  }

  return any;

})();

optional = (function() {
  function optional(schema, defaultValue) {
    if (!(this instanceof optional)) {
      return new optional(schema, defaultValue);
    }
    this.schema = schema;
    this.defaultValue = defaultValue;
  }

  return optional;

})();

either = (function(_super) {
  __extends(either, _super);

  function either(a, b) {
    if (!(this instanceof either)) {
      return new either(a, b);
    }
    this.a = a;
    this.b = b;
  }

  either.prototype.validate = function(data, options) {
    var errors, tryA, tryB;

    tryB = {};
    tryA = validate(this.a, data, options);
    if (tryA.errors) {
      tryB = validate(this.b, data, options);
    }
    if (tryB.errors) {
      errors = [tryA.errors, tryB.errors];
    }
    return {
      errors: errors,
      data: tryA.data || tryB.data
    };
  };

  return either;

})(type);

validate = function(schema, data, options) {
  var errors, idx, newData, subSchema, tryX, x;

  if (options == null) {
    options = {};
  }
  errors = void 0;
  if (data === void 0) {
    if (schema instanceof optional) {
      data = schema.defaultValue;
    } else {
      errors = "missing value";
    }
    return {
      errors: errors,
      data: data
    };
  }
  if (schema instanceof type) {
    return schema.validate(data, options);
  }
  if (schema instanceof any || schema === any) {
    return {
      errors: errors,
      data: data
    };
  }
  if (schema instanceof optional) {
    schema = schema.schema;
  }
  if (schema === Number) {
    if (options.weak) {
      data = Number(data);
    }
    if (!isNumber(data || isNaN(data))) {
      errors = "should be a number";
    }
  } else if (schema === String) {
    if (!isString(data)) {
      errors = "should be a string";
    }
  } else if (schema === Boolean) {
    if (options.weak) {
      data = isBoolean(data) ? data : contains(['true', '1', 'yes'], data.toLowerCase()) ? true : contains(['false', '0', 'no'], data.toLowerCase()) ? false : void 0;
    }
    if (!isBoolean(data)) {
      errors = "should be a boolean";
    }
  } else if (schema === Date) {
    if (options.weak) {
      data = new Date(data);
    }
    if (!isDate(data || isNaN(data.getDate()))) {
      errors = "should be a date";
    }
  } else if (isArray(schema)) {
    if (!isArray(data)) {
      errors = "should be an array";
    } else {
      newData = (function() {
        var _i, _len, _results;

        _results = [];
        for (idx = _i = 0, _len = data.length; _i < _len; idx = ++_i) {
          x = data[idx];
          tryX = validate(schema[0], x, options);
          if (tryX.errors) {
            errors = errors || {};
            errors[idx] = tryX.errors;
          }
          _results.push(tryX.data);
        }
        return _results;
      })();
      return {
        errors: errors,
        data: newData
      };
    }
  } else {
    if (!isObject(data)) {
      errors = "should be an object";
    } else {
      newData = {};
      for (idx in schema) {
        subSchema = schema[idx];
        tryX = validate(subSchema, data[idx], options);
        if (tryX.errors) {
          errors = errors || {};
          errors[idx] = tryX.errors;
        }
        newData[idx] = tryX.data;
      }
      return {
        errors: errors,
        data: newData
      };
    }
  }
  return {
    errors: errors,
    data: data
  };
};

module.exports = {
  validate: validate,
  type: type,
  optional: optional,
  either: either,
  any: any
};
